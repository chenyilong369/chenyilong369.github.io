(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{434:function(t,s,a){"use strict";a.r(s);var i=a(41),e=Object(i.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"栈调和"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈调和"}},[t._v("#")]),t._v(" 栈调和")]),t._v(" "),a("p",[t._v("在了解 React 16 Fiber 架构前，先了解一下 React 15 的栈调和算法。")]),t._v(" "),a("h2",{attrs:{id:"调和过程与-diff-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调和过程与-diff-算法"}},[t._v("#")]),t._v(" 调和过程与 Diff 算法")]),t._v(" "),a("p",[t._v("“调和”又译为“协调”，协调过程的官方定义，藏在 React 官网对虚拟 DOM 这一概念的解释中，原文如下：")]),t._v(" "),a("blockquote",[a("p",[t._v("Virtual DOM 是一种编程概念。在这个概念里，UI 以一种 想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫作协调（调和）。")])]),t._v(" "),a("p",[a("strong",[t._v("通过如 ReactDOM 等类库使虚拟 DOM 与“真实的” DOM 同步，这一过程叫作协调（调和）")]),t._v("。")]),t._v(" "),a("p",[t._v("Diff 是调和过程中最具代表性的一环")]),t._v(" "),a("h3",{attrs:{id:"diff-算法思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法思想"}},[t._v("#")]),t._v(" Diff 算法思想")]),t._v(" "),a("p",[t._v("Diff 算法其实就是“找不同”的过程。在计算机科学领域，要想找出两个树结构之间的不同, 传统的计算方法是通过循环递归进行树节点的一一对比,  这个过程的算法复杂度是 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",{attrs:{stretchy:"false"}},[t._v("(")]),a("msup",[a("mi",[t._v("n")]),a("mn",[t._v("3")])],1),a("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n^3)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"1.064108em","vertical-align":"-0.25em"}}),a("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord"},[a("span",{staticClass:"mord mathdefault"},[t._v("n")]),a("span",{staticClass:"msupsub"},[a("span",{staticClass:"vlist-t"},[a("span",{staticClass:"vlist-r"},[a("span",{staticClass:"vlist",staticStyle:{height:"0.8141079999999999em"}},[a("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[a("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),a("span",{staticClass:"sizing reset-size6 size3 mtight"},[a("span",{staticClass:"mord mtight"},[t._v("3")])])])])])])])]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v("。")]),t._v(" "),a("p",[t._v("React 团队结合设计层面的一些推导，总结了以下规律， 为将 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",{attrs:{stretchy:"false"}},[t._v("(")]),a("msup",[a("mi",[t._v("n")]),a("mn",[t._v("3")])],1),a("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n^3)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"1.064108em","vertical-align":"-0.25em"}}),a("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord"},[a("span",{staticClass:"mord mathdefault"},[t._v("n")]),a("span",{staticClass:"msupsub"},[a("span",{staticClass:"vlist-t"},[a("span",{staticClass:"vlist-r"},[a("span",{staticClass:"vlist",staticStyle:{height:"0.8141079999999999em"}},[a("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[a("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),a("span",{staticClass:"sizing reset-size6 size3 mtight"},[a("span",{staticClass:"mord mtight"},[t._v("3")])])])])])])])]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v(" 复杂度转换成 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",{attrs:{stretchy:"false"}},[t._v("(")]),a("mi",[t._v("n")]),a("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord mathdefault"},[t._v("n")]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v(" 复杂度确立了大前提：")]),t._v(" "),a("ul",[a("li",[t._v("若两个组件属于同一个类型，那么它们将拥有相同的 DOM 树形结构；")]),t._v(" "),a("li",[t._v("处于同一层级的一组子节点，可用通过设置 key 作为唯一标识，从而维持各个节点在不同渲染过程中的稳定性。")]),t._v(" "),a("li",[t._v("DOM 节点之间的跨层级操作并不多，同层级操作是主流。")])]),t._v(" "),a("img",{attrs:{src:t.$withBase("/react/stack01.png"),alt:"stack01"}}),t._v(" "),a("p",[t._v("那么我们可以总结出 Diff 算法的一些规律：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Diff 算法性能突破的关键点在于“分层对比”；")])]),t._v(" "),a("li",[a("p",[t._v("类型一致的节点才有继续 Diff 的必要性；")])]),t._v(" "),a("li",[a("p",[t._v("key 属性的设置，可以帮我们尽可能重用同一层级内的节点。")])])]),t._v(" "),a("h4",{attrs:{id:"分层对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分层对比"}},[t._v("#")]),t._v(" 分层对比")]),t._v(" "),a("p",[t._v("结合“DOM 节点之间的跨层级操作并不多，同层级操作是主流”这一规律，React 的 Diff 过程直接放弃了跨层级的节点比较，它只针对相同层级的节点作对比。")]),t._v(" "),a("p",[t._v("如果真的发生了跨层级操作呢？比如移动节点，在这种情况下 React 并不能够判断出“移动”这个行为，它只能机械地认为移出子树那一层的组件消失了，对应子树需要被销毁；而移入子树的那一层新增了一个组件，需要重新为其创建一棵子树。")]),t._v(" "),a("p",[t._v("销毁 + 重建的代价是昂贵的，因此 React 官方也建议开发者不要做跨层级的操作，尽量保持 DOM 结构的稳定性。")]),t._v(" "),a("h4",{attrs:{id:"减少递归"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#减少递归"}},[t._v("#")]),t._v(" 减少递归")]),t._v(" "),a("p",[t._v("React 认为，只有同类型的组件，才有进一步对比的必要性；若参与 Diff 的两个组件类型不同，那么直接放弃比较，原地替换掉旧的节点。")]),t._v(" "),a("h4",{attrs:{id:"重用节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重用节点"}},[t._v("#")]),t._v(" 重用节点")]),t._v(" "),a("p",[t._v("React 对 key 属性的定义：")]),t._v(" "),a("blockquote",[a("p",[t._v("key 是用来帮助 React 识别哪些内容被更改、添加或者删除。key 需要写在用数组渲染出来的元素内部，并且需要赋予其一个稳定的值。稳定在这里很重要，因为如果 key 值发生了变更，React 则会触发 UI 的重渲染。这是一个非常有用的特性。")])]),t._v(" "),a("p",[t._v("它试图解决的是同一层级下节点的重用问题。")])])}),[],!1,null,null,null);s.default=e.exports}}]);