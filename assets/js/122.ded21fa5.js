(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{481:function(t,v,_){"use strict";_.r(v);var e=_(41),a=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"http-html-浏览器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-html-浏览器"}},[t._v("#")]),t._v(" HTTP,HTML,浏览器")]),t._v(" "),_("h2",{attrs:{id:"说一下-http-和-https"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#说一下-http-和-https"}},[t._v("#")]),t._v(" 说一下 http 和 https")]),t._v(" "),_("h4",{attrs:{id:"基本概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),_("p",[_("strong",[t._v("http")]),t._v(": 超文本传输协议,是互联网上应用最为广泛的一种网络协议,是一个客户端和服务器端请求和应答的标准(TCP)，用于从 WWW 服务器传输超文本到本地浏览器的传输协议,它可以使浏览器更加高效，使网络传输减少。")]),t._v(" "),_("p",[_("strong",[t._v("https")]),t._v(": 是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版,即 HTTP 下加入 SSL 层，HTTPS的安全基础是 SSL，因此加密的详细内容就需要 SSL。")]),t._v(" "),_("h4",{attrs:{id:"区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[t._v("#")]),t._v(" 区别")]),t._v(" "),_("ul",[_("li",[t._v("https 协议需要 ca 证书，费用较高。")]),t._v(" "),_("li",[t._v("http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。")]),t._v(" "),_("li",[t._v("使用不同的链接方式，端口也不同，一般而言，http 协议的端口为 80，https 的端口为 443。")]),t._v(" "),_("li",[t._v("http 的连接很简单，是无状态的；https 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。")])]),t._v(" "),_("h4",{attrs:{id:"https-的工作原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https-的工作原理"}},[t._v("#")]),t._v(" https 的工作原理")]),t._v(" "),_("p",[t._v("客户使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。")]),t._v(" "),_("p",[t._v("web 服务器接收到客户端的请求之后，会将网站的证书(证书中包含了公钥),返回或者说传输给客户端。")]),t._v(" "),_("p",[t._v("客户端和 web 服务器端开始协商 SSL 链接的安全等级,也就是加密等级。")]),t._v(" "),_("p",[t._v("客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。")]),t._v(" "),_("p",[t._v("web 服务器通过自己的私钥解密出会话密钥。")]),t._v(" "),_("p",[t._v("web 服务器通过会话密钥加密与客户端之间的通信。")]),t._v(" "),_("h4",{attrs:{id:"https-的优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https-的优点"}},[t._v("#")]),t._v(" https 的优点")]),t._v(" "),_("p",[t._v("使用 https 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器;")]),t._v(" "),_("p",[t._v("https 协议是由 ssl + http 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。")]),t._v(" "),_("p",[t._v("https 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。")]),t._v(" "),_("p",[t._v("谷歌曾在 2014 年 8 月份调整搜索引擎算法，并称“比起同等 HTTP 网站，采用 HTTPS 加密的\n网站在搜索结果中的排名将会更高”。")]),t._v(" "),_("h4",{attrs:{id:"https-协议的缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https-协议的缺点"}},[t._v("#")]),t._v(" https 协议的缺点")]),t._v(" "),_("p",[t._v("https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。")]),t._v(" "),_("p",[t._v("https 缓存不如 http 高效，会增加数据开销。")]),t._v(" "),_("p",[t._v("ssl 证书也需要钱，功能越强大的证书费用越高。")]),t._v(" "),_("p",[t._v("ssl 证书需要绑定 ip，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。")]),t._v(" "),_("h2",{attrs:{id:"tcp-三次握手-四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-三次握手-四次挥手"}},[t._v("#")]),t._v(" *tcp 三次握手，四次挥手")]),t._v(" "),_("img",{attrs:{src:t.$withBase("/webDesignBase01.png"),alt:"webDesignBase01"}}),t._v(" "),_("p",[t._v("第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。")]),t._v(" "),_("p",[t._v("第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；")]),t._v(" "),_("p",[t._v("第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。")]),t._v(" "),_("p",[t._v("以上是三次握手。下面是四次挥手")]),t._v(" "),_("p",[t._v("1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。")]),t._v(" "),_("p",[t._v("2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。")]),t._v(" "),_("p",[t._v("3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。")]),t._v(" "),_("p",[t._v("4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。")]),t._v(" "),_("p",[t._v("5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCP后，才进入CLOSED状态。")]),t._v(" "),_("p",[t._v("6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCP后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。")]),t._v(" "),_("h4",{attrs:{id:"一些题目"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一些题目"}},[t._v("#")]),t._v(" 一些题目")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("为什么连接的时候是三次握手，关闭的时候却是四次握手？")])])]),t._v(" "),_("p",[t._v('因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。')]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[_("strong",[t._v("为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？")])])]),t._v(" "),_("p",[t._v("虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。")]),t._v(" "),_("p",[t._v("所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。")]),t._v(" "),_("p",[t._v("Client会在发送出ACK之后进入到TIME_WAIT状态。")]),t._v(" "),_("p",[t._v("Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。")]),t._v(" "),_("p",[t._v("如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。")]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[_("strong",[t._v("为什么不能用两次握手进行连接？")])])]),t._v(" "),_("p",[t._v("3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。")]),t._v(" "),_("p",[t._v("现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。")]),t._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[_("strong",[t._v("如果已经建立了连接，但是客户端突然出现故障了怎么办？")])])]),t._v(" "),_("p",[t._v("TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。")]),t._v(" "),_("h2",{attrs:{id:"tcp-和-udp-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-和-udp-的区别"}},[t._v("#")]),t._v(" TCP 和 UDP 的区别")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("TCP 是面向连接的，UDP 是无连接的即发送数据前不需要先建立链接。")])]),t._v(" "),_("li",[_("p",[t._v("TCP 提供可靠的服务。也就是说通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付。 并且因为 tcp 可靠，面向连接，不会丢失数据因此适合大数据量的交换。")])]),t._v(" "),_("li",[_("p",[t._v("TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低(因此会出现丢包，对实时的应用比如 IP 电话和视频会议等)。")])]),t._v(" "),_("li",[_("p",[t._v("TCP 只能是 1 对 1 的，UDP 支持 1 对 1，1 对多。")])]),t._v(" "),_("li",[_("p",[t._v("TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。")])]),t._v(" "),_("li",[_("p",[t._v("TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。")])])]),t._v(" "),_("h2",{attrs:{id:"websocket-的实现和应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#websocket-的实现和应用"}},[t._v("#")]),t._v(" WebSocket 的实现和应用")]),t._v(" "),_("h4",{attrs:{id:"什么是-websocket"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是-websocket"}},[t._v("#")]),t._v(" 什么是 WebSocket?")]),t._v(" "),_("p",[t._v("HTML5新增协议，它的目的在浏览器和服务器之间建立一个不受限的双向实时通信的通道。比如，服务器可以任意时刻发送消息给浏览器。它是基于TCP，先通过HTTP/HTTPS协议发起一条特殊的HTTP请求进行握手后创建一个用于交换数据的TCP连接。")]),t._v(" "),_("p",[t._v("Websocket 使用 ws 或 wss 的统一资源标志符。")]),t._v(" "),_("h4",{attrs:{id:"它的优势是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#它的优势是什么"}},[t._v("#")]),t._v(" "),_("strong",[t._v("它的优势是什么?")])]),t._v(" "),_("ul",[_("li",[t._v("浏览器和服务器只要一次握手动作。")]),t._v(" "),_("li",[t._v("双方可以在任意时刻，相互推送消息。")]),t._v(" "),_("li",[t._v("服务器和浏览器之间交换的头信息很小。")])]),t._v(" "),_("h4",{attrs:{id:"websocket与传统http协议区别是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#websocket与传统http协议区别是什么"}},[t._v("#")]),t._v(" "),_("strong",[t._v("WebSocket与传统HTTP协议区别是什么?")])]),t._v(" "),_("ul",[_("li",[t._v("HTTP协议，浏览器不主动请求，服务器没法发送数据给浏览器。")]),t._v(" "),_("li",[t._v("HTTP协议每次链接都必须是三次握手才能发送消息，WebSocket只要一次就能发送消息。")]),t._v(" "),_("li",[t._v("HTTP协议每次请求都要发送head，WebSocket一旦建立链接，之后请求就不要发送head。")])]),t._v(" "),_("p",[t._v("HTTP可用轮询或comet机制实现WebSocket功能，但是有缺点。")]),t._v(" "),_("p",[_("strong",[t._v("轮询")]),t._v("：js启动定时器，以固定时间间隔给服务器发送请求，询问服务器有没有新消息。")]),t._v(" "),_("ul",[_("li",[t._v("实时性不够")]),t._v(" "),_("li",[t._v("频繁请求給服务器造成很大压力")])]),t._v(" "),_("p",[_("strong",[t._v("comet")]),t._v("：请求没有超过预定时间或者没有返回数据，一直保持链接状态。等有数据，再推送。")]),t._v(" "),_("ul",[_("li",[t._v("线程挂起，浪费服务器资源")]),t._v(" "),_("li",[t._v("长时间没有数据，链路上任何一个网关都可能关闭这个链接。这要求comet连接必须定期发ping，检查连接是否正常。")])]),t._v(" "),_("h4",{attrs:{id:"如何使用websocket"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何使用websocket"}},[t._v("#")]),t._v(" "),_("strong",[t._v("如何使用WebSocket?")])]),t._v(" "),_("p",[t._v("WebSocket链接必须由浏览器发起，虽然基于HTTP协议发展，但是和HTTP协议不一样。请求以ws://开头的地址，请求头申明这是WebSocket链接。服务器返回，表示成功建立WebSocket。")]),t._v(" "),_("h2",{attrs:{id:"几个很实用的-bom-属性对象方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#几个很实用的-bom-属性对象方法"}},[t._v("#")]),t._v(" 几个很实用的 BOM 属性对象方法?")]),t._v(" "),_("p",[t._v("Bom 是浏览器对象。")]),t._v(" "),_("h4",{attrs:{id:"location-对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#location-对象"}},[t._v("#")]),t._v(" location 对象")]),t._v(" "),_("ul",[_("li",[t._v("location.href-- 返回或设置当前文档的 URL")]),t._v(" "),_("li",[t._v("location.search -- 返回 URL 中的查询字符串部分。例如 http://www.baidu.com?id=5&name=dreamdu 返回包括(?)后面的内容?id=5&name=dreamdu")]),t._v(" "),_("li",[t._v("location.hash -- 返回 URL#后面的内容，如果没有#，返回空。")]),t._v(" "),_("li",[t._v("location.host -- 返回 URL 中的域名部分，例如 www.dreamdu.com")]),t._v(" "),_("li",[t._v("location.hostname -- 返回 URL 中的主域名部分，例如 dreamdu.com")]),t._v(" "),_("li",[t._v("location.pathname -- 返回 URL 的域名后的部分。例如http://chenyilong369.github.io/webDesign/ 返回/webDesign/")]),t._v(" "),_("li",[t._v("location.port -- 返回 URL 中的端口部分。例如 http://localhost:8080/xhtml/返回 8080")]),t._v(" "),_("li",[t._v("location.protocol -- 返回 URL 中的协议部分。例如 http://localhost:8080/xhtml/ 返回(//)前面的内容 http:")]),t._v(" "),_("li",[t._v("location.assign -- 设置当前文档的 URL")]),t._v(" "),_("li",[t._v("location.replace() -- 设置当前文档的 URL，并且在 history 对象的地址列表中移除这个 URL")]),t._v(" "),_("li",[t._v("location.replace(url);")]),t._v(" "),_("li",[t._v("location.reload() -- 重载当前页面")])]),t._v(" "),_("h4",{attrs:{id:"history-对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#history-对象"}},[t._v("#")]),t._v(" history 对象")]),t._v(" "),_("ul",[_("li",[t._v("history.go() -- 前进或后退指定的页面数 history.go(num);")]),t._v(" "),_("li",[t._v("history.back() -- 后退一页")]),t._v(" "),_("li",[t._v("history.forward() -- 前进一页")])]),t._v(" "),_("h4",{attrs:{id:"navigator-对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#navigator-对象"}},[t._v("#")]),t._v(" Navigator 对象")]),t._v(" "),_("ul",[_("li",[t._v("navigator.userAgent -- 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)")]),t._v(" "),_("li",[t._v("navigator.cookieEnabled -- 返回浏览器是否支持(启用)cookie")])]),t._v(" "),_("h2",{attrs:{id:"说一下-html5-drag-api"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#说一下-html5-drag-api"}},[t._v("#")]),t._v(" 说一下 HTML5 drag api")]),t._v(" "),_("ul",[_("li",[t._v("dragstart:事件主体是被拖放元素,在开始拖放被拖放元素时触发,。")]),t._v(" "),_("li",[t._v("darg:事件主体是被拖放元素,在正在拖放被拖放元素时触发。")]),t._v(" "),_("li",[t._v("dragenter:事件主体是目标元素,在被拖放元素进入某元素时触发。")]),t._v(" "),_("li",[t._v("dragover:事件主体是目标元素,在被拖放在某元素内移动时触发。")]),t._v(" "),_("li",[t._v("dragleave:事件主体是目标元素,在被拖放元素移出目标元素是触发。")]),t._v(" "),_("li",[t._v("drop:事件主体是目标元素,在目标元素完全接受被拖放元素时触发。")]),t._v(" "),_("li",[t._v("dragend:事件主体是被拖放元素,在整个拖放操作结束时触发")])]),t._v(" "),_("h2",{attrs:{id:"说一下-http2-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#说一下-http2-0"}},[t._v("#")]),t._v(" 说一下 http2.0")]),t._v(" "),_("ul",[_("li",[t._v("提升访问速度(可以对于,请求资源所需时间更少,访问速度更快,相比 http1.0)")]),t._v(" "),_("li",[t._v("允许多路复用:多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改善了:在 http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制(连接数量)，超过限制会被阻塞。")]),t._v(" "),_("li",[t._v("二进制分帧:HTTP2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码")]),t._v(" "),_("li",[t._v("首部压缩")]),t._v(" "),_("li",[t._v("服务器端推送")])]),t._v(" "),_("h2",{attrs:{id:"fetch-发送-2-次请求的原因"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#fetch-发送-2-次请求的原因"}},[t._v("#")]),t._v(" fetch 发送 2 次请求的原因")]),t._v(" "),_("p",[t._v("fetch 发送 post 请求的时候，总是发送 2 次，第一次状态码是 204，第二次才成功。")]),t._v(" "),_("p",[_("strong",[t._v("204 No Content")]),t._v("：该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。")]),t._v(" "),_("p",[t._v("当发生跨域请求时，fetch会先发送一个OPTIONS请求，来确认服务器是否允许接受请求服务器同意后，才会发送真正的请求。")]),t._v(" "),_("h2",{attrs:{id:"cookie、sessionstorage、localstorage"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cookie、sessionstorage、localstorage"}},[t._v("#")]),t._v(" Cookie、sessionStorage、localStorage")]),t._v(" "),_("p",[t._v("共同点 : 都是保存在浏览器端，并且是同源的。")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("cookie：cookie 数据始终在同源的 http 请求中携带(即使不需要)，即 cookie 在浏览器和服务器间来回传递。而sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。cookie 数据还有路径(path)的概念，可以限制 cookie 只属于某个路径下，存储的大小很小只有 4K 左右。")])]),t._v(" "),_("li",[_("p",[t._v("sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持。")])]),t._v(" "),_("li",[_("p",[t._v("localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据。")])])]),t._v(" "),_("p",[t._v("localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。")]),t._v(" "),_("p",[t._v("cookie 的作用：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("保存用户登录状态。例如将用户 id 存储于一个 cookie 内，这样当用户下次访问该页面时就不需要重新登录了。cookie 还可以设置过期时间，当超过时间期限后，cookie 就会自动消失。")])]),t._v(" "),_("li",[_("p",[t._v("跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie 后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。")])]),t._v(" "),_("li",[_("p",[t._v("定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用 cookie 来记录用户的选项，例如:背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。")])])]),t._v(" "),_("h2",{attrs:{id:"说一下-web-worker"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#说一下-web-worker"}},[t._v("#")]),t._v(" 说一下 web worker")]),t._v(" "),_("p",[t._v("Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。")]),t._v(" "),_("p",[t._v("这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。")]),t._v(" "),_("p",[t._v("Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。")]),t._v(" "),_("p",[t._v("Web Worker 有以下几个使用注意点。")]),t._v(" "),_("p",[t._v("（1）"),_("strong",[t._v("同源限制")])]),t._v(" "),_("p",[t._v("分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。")]),t._v(" "),_("p",[t._v("（2）"),_("strong",[t._v("DOM 限制")])]),t._v(" "),_("p",[t._v("Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用"),_("code",[t._v("document")]),t._v("、"),_("code",[t._v("window")]),t._v("、"),_("code",[t._v("parent")]),t._v("这些对象。但是，Worker 线程可以"),_("code",[t._v("navigator")]),t._v("对象和"),_("code",[t._v("location")]),t._v("对象。")]),t._v(" "),_("p",[t._v("（3）"),_("strong",[t._v("通信联系")])]),t._v(" "),_("p",[t._v("Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。")]),t._v(" "),_("p",[t._v("（4）"),_("strong",[t._v("脚本限制")])]),t._v(" "),_("p",[t._v("Worker 线程不能执行"),_("code",[t._v("alert()")]),t._v("方法和"),_("code",[t._v("confirm()")]),t._v("方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。")]),t._v(" "),_("p",[t._v("（5）"),_("strong",[t._v("文件限制")])]),t._v(" "),_("p",[t._v("Worker 线程无法读取本地文件，即不能打开本机的文件系统（"),_("code",[t._v("file://")]),t._v("），它所加载的脚本，必须来自网络。")]),t._v(" "),_("h2",{attrs:{id:"对-html-语义化标签的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对-html-语义化标签的理解"}},[t._v("#")]),t._v(" 对 HTML 语义化标签的理解")]),t._v(" "),_("p",[t._v("HTML5 语义化标签是指正确的标签包含了正确的内容，结构良好，便于阅读，比如 nav 表示导航条，类似的还有 article、header、footer 等等标签。")]),t._v(" "),_("h2",{attrs:{id:"doctype-作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#doctype-作用"}},[t._v("#")]),t._v(" Doctype 作用")]),t._v(" "),_("p",[t._v("Doctype 声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。")]),t._v(" "),_("p",[t._v("严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。")]),t._v(" "),_("p",[t._v("混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。")]),t._v(" "),_("h2",{attrs:{id:"cookie-如何防范-xss-攻击"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cookie-如何防范-xss-攻击"}},[t._v("#")]),t._v(" Cookie 如何防范 XSS 攻击")]),t._v(" "),_("p",[t._v("XSS(跨站脚本攻击)是指攻击者在返回的 HTML 中嵌入 javascript 脚本，为了减轻这些攻击，需要在 HTTP 头部配上，set-cookie:")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("httponly-这个属性可以防止 XSS,它会禁止 javascript 脚本来访问 cookie。")])]),t._v(" "),_("li",[_("p",[t._v("secure - 这个属性告诉浏览器仅在请求为 https 的时候发送 cookie")])])]),t._v(" "),_("h2",{attrs:{id:"cookie和session的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cookie和session的区别"}},[t._v("#")]),t._v(" Cookie和Session的区别")]),t._v(" "),_("ul",[_("li",[t._v("cookie 数据存放在客户的浏览器上,session 数据放在服务器上。")]),t._v(" "),_("li",[t._v("cookie 不是很安全,别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗，考虑到安全应当使用 session")]),t._v(" "),_("li",[t._v("session 会在一定时间内保存在服务器上。当访问增多,会比较占用你服务器的性能考虑到减轻服务器性能方面,应当使用 COOKIE。")]),t._v(" "),_("li",[t._v("单个 cookie 保存的数据不能超过 4K,很多浏览器都限制一个站点最多保存 20 个cookie。")])]),t._v(" "),_("h2",{attrs:{id:"一句话概括-restful"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一句话概括-restful"}},[t._v("#")]),t._v(" 一句话概括 RESTFUL")]),t._v(" "),_("p",[t._v("就是用 URL 定位资源，用 HTTP 描述操作。")]),t._v(" "),_("h2",{attrs:{id:"get-和-post-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#get-和-post-的区别"}},[t._v("#")]),t._v(" GET 和 POST 的区别")]),t._v(" "),_("ul",[_("li",[t._v("get 参数通过 url 传递，post 放在 request body 中。")]),t._v(" "),_("li",[t._v("get 请求在 url 中传递的参数是有长度限制的，而 post 没有。")]),t._v(" "),_("li",[t._v("get 比 post 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息。")]),t._v(" "),_("li",[t._v("get 请求只能进行 url 编码，而 post 支持多种编码方式")]),t._v(" "),_("li",[t._v("get 请求参数会被完整保留在浏览历史记录里,而 post 中的参数不会被保留。")]),t._v(" "),_("li",[t._v("GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。")]),t._v(" "),_("li",[t._v("GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。")])]),t._v(" "),_("h2",{attrs:{id:"描述一下-xss-和-crsf-攻击-防御方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#描述一下-xss-和-crsf-攻击-防御方法"}},[t._v("#")]),t._v(" 描述一下 XSS 和 CRSF 攻击?防御方法?")]),t._v(" "),_("p",[t._v("XSS, 即为(Cross Site Scripting)，中文名为跨站脚本， 是发生在目标用户的浏览器层面上的，当渲染 DOM 树的过程成发生了不在预期内执行的 JS 代码时，就发生了 XSS 攻击。大多数 XSS 攻击的主要方式是嵌入一段远程或者第三方域上的 JS 代码。实际上是在目标网站的作用域下执行了这段 js 代码。")]),t._v(" "),_("p",[t._v("CSRF(Cross Site Request Forgery,跨站请求伪造)，字面理解意思就是在别的站点伪造了一个请求。专业术语来说就是在受害者访问一个网站时，其 Cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。")]),t._v(" "),_("p",[t._v("XSS 防御的总体思路是:对输入(和 URL 参数)进行过滤，对输出进行编码。也就是对提交的所有内容进行过滤，对 url 中的参数进行过滤，过滤掉会导致脚本执行的相关内容;然后对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。虽然对输入过滤可以被绕过，但是也还是会拦截很大一部分的 XSS 攻击。")]),t._v(" "),_("p",[t._v("防御 CSRF 攻击主要有三种策略:验证 HTTP Referer 字段;在请求地址中添加 token 并验证;在 HTTP 头中自定义属性并验证。")]),t._v(" "),_("h2",{attrs:{id:"前端优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端优化"}},[t._v("#")]),t._v(" 前端优化")]),t._v(" "),_("p",[t._v("降低请求量: 合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。")]),t._v(" "),_("p",[t._v("加快请求速度: 预解析 DNS，减少域名数，并行加载，CDN 分发。")]),t._v(" "),_("p",[t._v("缓存: HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。")]),t._v(" "),_("p",[t._v("渲染: JS/CSS 优化，加载顺序，服务端渲染，pipeline。")])])}),[],!1,null,null,null);v.default=a.exports}}]);