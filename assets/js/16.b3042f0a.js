(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{375:function(v,_,t){"use strict";t.r(_);var s=t(41),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"渲染引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#渲染引擎"}},[v._v("#")]),v._v(" 渲染引擎")]),v._v(" "),t("p",[t("strong",[v._v("渲染引擎")]),v._v("又名"),t("strong",[v._v("浏览器内核")]),v._v("，指负责对网页语法解析并渲染成一张可视化页面的解析器。它是浏览器最核心最重要的部位，不同内核对网页语法的解析也有不同，因此同一网页语法在不同内核的浏览器中的渲染效果也可能不同，这就是常说的"),t("strong",[v._v("浏览器差异性")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"渲染过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程"}},[v._v("#")]),v._v(" 渲染过程")]),v._v(" "),t("p",[v._v("要了解浏览器页面的渲染过程，首先得知道"),t("code",[v._v("关键渲染路径")]),v._v("。"),t("strong",[v._v("关键渲染路径")]),v._v("指浏览器从最初接收请求得到HTML、CSS、JS等资源，然后解析、构建、渲染、布局、绘制、合成，到最后呈现在用户眼前界面的整个过程。")]),v._v(" "),t("p",[v._v("在这将页面的渲染过程分为以下几部分。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("解析文件")]),v._v(" "),t("ul",[t("li",[v._v("将 html 文件转换为DOM树")]),v._v(" "),t("li",[v._v("将 css 文件转换为CSSOM树")]),v._v(" "),t("li",[v._v("将 DOM 树和 CSSOM 树合并生成渲染树")])])]),v._v(" "),t("li",[t("strong",[v._v("绘制图层")]),v._v(" "),t("ul",[t("li",[v._v("根据渲染树生成布局渲染树(回流)")]),v._v(" "),t("li",[v._v("根据布局渲染树生成绘制渲染树(重绘)")])])]),v._v(" "),t("li",[t("strong",[v._v("合成图层")]),v._v("：根据绘制渲染树合成图层显示在屏幕上")])]),v._v(" "),t("h3",{attrs:{id:"解析文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解析文件"}},[v._v("#")]),v._v(" 解析文件")]),v._v(" "),t("p",[v._v("HTML 文档描述了一个网页的结构，，浏览器通过 HTML 解析器将 HTML 解析成 DOM 树结构。")]),v._v(" "),t("p",[v._v("构建 DOM 树的过程：读取HTML文档的"),t("strong",[v._v("字节")]),v._v("，将字节转换成"),t("strong",[v._v("字符")]),v._v("，依据字符确定"),t("strong",[v._v("标签")]),v._v("，将标签转换成"),t("strong",[v._v("节点")]),v._v("，以节点为基准构建"),t("strong",[v._v("DOM树")]),v._v("。")]),v._v(" "),t("p",[v._v("CSS文档描述一个页面的表现，浏览器通过 CSS 解析器将 CSS 解析成 CSSOM 树结构，与 DOM 树结构比较像。构建过程也与 DOM 树类似。")]),v._v(" "),t("p",[v._v("值得注意的是，在构建DOM树的过程中，当"),t("code",[v._v("HTML解析器")]),v._v("遇到"),t("code",[v._v("<script>")]),v._v("时会立即阻塞DOM树的构建，将控制权移交给浏览器的"),t("code",[v._v("JS引擎")]),v._v("，等到"),t("code",[v._v("JS引擎")]),v._v("运行完毕，浏览器才会从中断的地方恢复DOM树的构建。"),t("code",[v._v("<script>")]),v._v("的脚本加载完成后，"),t("code",[v._v("JS引擎")]),v._v("通过"),t("code",[v._v("DOM API")]),v._v("和"),t("code",[v._v("CSSOM API")]),v._v("操作DOM树和CSSOM树。为何会产生"),t("strong",[v._v("渲染阻塞")]),v._v("呢？其根本原因在于：JS操作DOM后，浏览器无法预测未来DOM的具体内容，为了防止无效操作和节省资源，只能阻塞DOM树的构建。")]),v._v(" "),t("p",[v._v("浏览器的"),t("code",[v._v("渲染引擎")]),v._v("将DOM树和CSSOM树合并生成渲染树，只渲染需显示的节点及其样式。")]),v._v(" "),t("img",{attrs:{src:v.$withBase("/internetCSS01.png"),alt:"internetCSS01"}}),v._v(" "),t("p",[v._v("由于上面三棵树的构建无先后条件以及顺序，会形成一边加载，一边解析，一边渲染的工作现象。")]),v._v(" "),t("h2",{attrs:{id:"绘制图层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#绘制图层"}},[v._v("#")]),v._v(" 绘制图层")]),v._v(" "),t("p",[v._v("进入绘制阶段，遍历渲染树，调用渲染器的"),t("code",[v._v("paint()")]),v._v("在屏幕上绘制内容。根据渲染树布局计算样式，即每个节点在页面中的布局、尺寸等几何属性。HTML默认是流式布局，CSS和JS会打破这种布局，改变DOM的几何属性和外观属性。在绘制过程中，根据渲染树布局，再根据布局绘制，这就是常听常说的"),t("strong",[v._v("回流重绘")]),v._v("。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("回流")]),v._v("：几何属性需改变的渲染")]),v._v(" "),t("li",[t("strong",[v._v("重绘")]),v._v("：更改外观属性而不影响几何属性的渲染")])]),v._v(" "),t("p",[v._v("在其他文章会重点讲解回流重绘，这里不再详细介绍。")]),v._v(" "),t("h2",{attrs:{id:"合成图层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#合成图层"}},[v._v("#")]),v._v(" 合成图层")]),v._v(" "),t("p",[v._v("将回流重绘生成的图层逐张合并并显示在屏幕上。上述几个步骤并不是一次性顺序完成的，若DOM或CSSOM被修改，上述过程会被重复执行。实际上，CSS和JS往往会多次修改DOM或CSSOM，简单来说就是用户的交互操作引发了网页的重渲染。")])])}),[],!1,null,null,null);_.default=r.exports}}]);