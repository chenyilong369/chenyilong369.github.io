(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{478:function(t,a,s){"use strict";s.r(a);var r=s(41),h=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"腾讯面试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#腾讯面试"}},[t._v("#")]),t._v(" 腾讯面试")]),t._v(" "),s("h2",{attrs:{id:"_2021-03-16-腾讯1面"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2021-03-16-腾讯1面"}},[t._v("#")]),t._v(" 2021-03-16 腾讯1面")]),t._v(" "),s("h3",{attrs:{id:"tcp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[t._v("#")]),t._v(" TCP")]),t._v(" "),s("h4",{attrs:{id:"tcp三次握手过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手过程"}},[t._v("#")]),t._v(" TCP三次握手过程")]),t._v(" "),s("p",[t._v("第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。")]),t._v(" "),s("p",[t._v("第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；")]),t._v(" "),s("p",[t._v("第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。")]),t._v(" "),s("h4",{attrs:{id:"能否将过程的次数减少为-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#能否将过程的次数减少为-2"}},[t._v("#")]),t._v(" 能否将过程的次数减少为 2")]),t._v(" "),s("p",[t._v("3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。")]),t._v(" "),s("p",[t._v("现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。")]),t._v(" "),s("h4",{attrs:{id:"如果之前连接过的-tcp-连接突然断开-再连接时我想一次握手连接-该怎么做"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如果之前连接过的-tcp-连接突然断开-再连接时我想一次握手连接-该怎么做"}},[t._v("#")]),t._v(" 如果之前连接过的 TCP 连接突然断开，再连接时我想一次握手连接，该怎么做")]),t._v(" "),s("p",[t._v("问了一下周围的大佬，才知道这题考的 WebSocket，")]),t._v(" "),s("h3",{attrs:{id:"http-与-https"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-与-https"}},[t._v("#")]),t._v(" HTTP 与 HTTPS")]),t._v(" "),s("h4",{attrs:{id:"说一说-http-与-https-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#说一说-http-与-https-的区别"}},[t._v("#")]),t._v(" 说一说 HTTP 与 HTTPS 的区别")]),t._v(" "),s("ul",[s("li",[t._v("https 协议需要 ca 证书，费用较高。")]),t._v(" "),s("li",[t._v("http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。")]),t._v(" "),s("li",[t._v("使用不同的链接方式，端口也不同，一般而言，http 协议的端口为 80，https 的端口为 443。")]),t._v(" "),s("li",[t._v("http 的连接很简单，是无状态的；https 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。")])]),t._v(" "),s("h4",{attrs:{id:"https-是如何加密和解密的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https-是如何加密和解密的"}},[t._v("#")]),t._v(" HTTPS 是如何加密和解密的")]),t._v(" "),s("p",[t._v("具体看博客 HTTPS 内容")])])}),[],!1,null,null,null);a.default=h.exports}}]);