(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{394:function(t,a,s){"use strict";s.r(a);var n=s(41),v=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"数据存储和回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据存储和回收"}},[t._v("#")]),t._v(" 数据存储和回收")]),t._v(" "),s("h2",{attrs:{id:"栈空间和堆空间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#栈空间和堆空间"}},[t._v("#")]),t._v(" 栈空间和堆空间")]),t._v(" "),s("p",[t._v("在此之前，我们先想想 JS 是什么类型的语言。在使用之前就需要确认其变量数据类型的称为"),s("code",[t._v("静态语言")]),t._v("，相反地，在运行过程中需要检查数据类型的语言称为"),s("code",[t._v("动态语言")]),t._v("。同时支持隐式类型转换的语言称为"),s("code",[t._v("弱类型语言")]),t._v("，不支持隐式类型转换的语言称为"),s("code",[t._v("强类型语言")]),t._v("。")]),t._v(" "),s("p",[t._v("可以推断出，JS 属于弱类型的、动态的语言。意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。意味着可以使用同一个变量保存不同类型的数据。")]),t._v(" "),s("p",[t._v("前面介绍过什么是原始类型，什么是引用类型。接下来我们来看看 JS 的内存结构。")]),t._v(" "),s("h3",{attrs:{id:"内存空间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存空间"}},[t._v("#")]),t._v(" 内存空间")]),t._v(" "),s("p",[t._v("在 JS 的执行过程中， 主要有三种类型内存空间，分别是"),s("code",[t._v("代码空间")]),t._v("、"),s("code",[t._v("栈空间")]),t._v("和"),s("code",[t._v("堆空间")]),t._v("。")]),t._v(" "),s("p",[t._v("这里的栈空间指的就是调用栈，用于存储执行上下文。")]),t._v(" "),s("p",[t._v("可以知道对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。")]),t._v(" "),s("p",[t._v("**原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。**当然这里补充一句，闭包变量是保存在堆内存中的。")]),t._v(" "),s("p",[t._v("为什么需要这么划分呢？如果所有数据存放在栈空间中，会影响执行上下文的切换效率，进而影响执行效率。")]),t._v(" "),s("p",[t._v("所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。")]),t._v(" "),s("p",[t._v("对于赋值操作，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。")]),t._v(" "),s("h2",{attrs:{id:"垃圾回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),s("p",[t._v("垃圾回收有两种策略：手动回收，自动回收。JS 属于自动回收策略。那么是怎么使用垃圾回收器自动进行垃圾回收的？")]),t._v(" "),s("p",[t._v("我们分析一段代码：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"jsChen"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("showName")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" c "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" d "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"chenyilong369"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("showName")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("当 foo 函数执行结束之后，foo 函数的执行上下文会从堆中被销毁掉，那么它是怎么被销毁的呢？")]),t._v(" "),s("p",[t._v("当执行完上面的代码后，调用栈上有一个记录当前执行状态的指针（称为 ESP）。此刻指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。")]),t._v(" "),s("p",[t._v("当执行完 showName 函数后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，这个下移操作就是"),s("code",[t._v("销毁 showName 函数执行上下文")]),t._v("的过程。")]),t._v(" "),s("p",[t._v("很明显，showName 的执行上下文还保存在调用栈中，但是此刻已经成为了无效内存，无法访问，当有新的执行上下文压入栈中时，这块内容会被直接覆盖掉。")]),t._v(" "),s("p",[t._v("上面说明的是栈中的数据回收，要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。")]),t._v(" "),s("h3",{attrs:{id:"代际假说"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代际假说"}},[t._v("#")]),t._v(" 代际假说")]),t._v(" "),s("p",[t._v("代际假说有两个特点：")]),t._v(" "),s("ul",[s("li",[t._v("大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；")]),t._v(" "),s("li",[t._v("不死的对象，会活得更久。")])]),t._v(" "),s("p",[t._v("下面就简要介绍一下 V8 的垃圾回收机制。")]),t._v(" "),s("p",[t._v("结合代际假说，在 V8 中会把堆分为"),s("code",[t._v("新生代")]),t._v("和"),s("code",[t._v("老生代")]),t._v("两个区域，"),s("code",[t._v("新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。")]),t._v("新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。")]),t._v(" "),s("p",[t._v("同时 V8 也为两个区域实现了各自的垃圾回收器：")]),t._v(" "),s("ul",[s("li",[t._v("副垃圾回收器，主要负责新生代的垃圾回收。")]),t._v(" "),s("li",[t._v("主垃圾回收器，主要负责老生代的垃圾回收。")])]),t._v(" "),s("h3",{attrs:{id:"引用计数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[t._v("#")]),t._v(" 引用计数")]),t._v(" "),s("p",[t._v("引用计数是一种回收策略，它跟踪记录每个值被引用的次数，每次引用的时候加一，被释放时减一，如果一个值的引用次数变成0了，就可以将其内存空间回收。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" obj "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 引用 +1")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" obj1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 引用 +1")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" obj "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 引用 -1")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" obj1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 引用为 0")]),t._v("\n\n")])])]),s("p",[t._v("当声明了一个变量并将一个引用类型值赋值该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另外一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存。")]),t._v(" "),s("p",[t._v("使用引用计数会有一个很严重的问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("problem")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" objectA "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" objectB "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n\n    objectA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" objectB"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    objectB"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" objectA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("在这个例子中，objectA 和 objectB 通过各自的属性相互引用；也就是说，这两个对象的引用次数都是 2。当函数执行完毕后，objectA 和 objectB 还将继续存在，因为它们的引用次数永远不会是 0。")]),t._v(" "),s("h3",{attrs:{id:"可能造成内存泄露的情况"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可能造成内存泄露的情况"}},[t._v("#")]),t._v(" 可能造成内存泄露的情况")]),t._v(" "),s("ol",[s("li",[t._v("对象之间的循环引用")]),t._v(" "),s("li",[t._v("老版IE（IE8及以前）里面DOM与对象之间的循环引用")]),t._v(" "),s("li",[t._v("全局变量会存在于整个应用生命周期，应用不退出不会回收，使用严格模式可以避免这种情况")]),t._v(" "),s("li",[t._v("闭包因为自身特性，将函数内部变量暴露到了外部作用域，当其自身执行结束时，所暴露的变量并不会回收")]),t._v(" "),s("li",[t._v("没有clear的定时器")])]),t._v(" "),s("h3",{attrs:{id:"垃圾回收器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器"}},[t._v("#")]),t._v(" 垃圾回收器")]),t._v(" "),s("p",[t._v("对于不同的垃圾回收器，实际上都是遵从共同的执行流程。")]),t._v(" "),s("p",[t._v("**首先标记空间中活动对象和非活动对象。**所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。")]),t._v(" "),s("p",[t._v("**然后回收非活动对象所占据的内存。**其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。")]),t._v(" "),s("p",[t._v("**最后做内存整理。**在回收内存时，难免导致内存中出现不连续空间，这种空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以需要将内存进行整理。")]),t._v(" "),s("p",[t._v("接下来，我们来看看 V8 的两个垃圾回收器。")]),t._v(" "),s("h4",{attrs:{id:"副垃圾回收器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#副垃圾回收器"}},[t._v("#")]),t._v(" 副垃圾回收器")]),t._v(" "),s("p",[t._v("通常情况下，大多数小的对象都会被分配到新生区，虽说这个区域不大，但是垃圾回收还是比较频繁的。")]),t._v(" "),s("p",[t._v("新生代中主要使用 Scavenge 算法来处理。")]),t._v(" "),s("img",{attrs:{src:t.$withBase("/storeAndDelete01.png"),alt:"storeAndDelete01"}}),t._v(" "),s("p",[t._v("Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。新加入的对象都会放在对象区域，当对象区域快被写满时，就会执行一次垃圾回收。")]),t._v(" "),s("p",[t._v("首先对对象区域中的垃圾做标记；标记完成之后，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。")]),t._v(" "),s("p",[t._v("完成复制后，将对象区域和空间区域进行角色翻转即可。这种操作还能让新生代中的这两块区域无限重复使用下去。")]),t._v(" "),s("p",[t._v("这样就可以解释新生区空间小的原因了，空间太大的话会导致复制的时间过长，影响执行效率。")]),t._v(" "),s("p",[t._v("也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JS 引擎采用了"),s("code",[t._v("对象晋升策略")]),t._v("，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。")]),t._v(" "),s("h4",{attrs:{id:"主垃圾回收器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主垃圾回收器"}},[t._v("#")]),t._v(" 主垃圾回收器")]),t._v(" "),s("p",[t._v("老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。所以不适合使用 Scavenge 算法。")]),t._v(" "),s("p",[t._v("主垃圾回收器是采用"),s("code",[t._v("标记 - 清除")]),t._v("的算法进行垃圾回收的。")]),t._v(" "),s("p",[t._v("首先是标记阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。")]),t._v(" "),s("p",[t._v("接下来就是垃圾的清除过程。它将标记为垃圾数据的数据直接进行清除。")]),t._v(" "),s("p",[t._v("上面的算法会导致出现内存碎片。于是产生了新的算法，"),s("code",[t._v("标记-整理")]),t._v("，清楚数据时不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。")]),t._v(" "),s("h4",{attrs:{id:"全停顿"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全停顿"}},[t._v("#")]),t._v(" 全停顿")]),t._v(" "),s("p",[t._v("由于 JS 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JS 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。这种行为称为"),s("code",[t._v("全停顿")]),t._v("。")]),t._v(" "),s("p",[t._v("可以设想一种这样的情景，当你的代码执行是突然有很多大的对象需要清除，这时会导致 JS 脚本暂停，页面可能会出现明显的卡顿。")]),t._v(" "),s("p",[t._v("对于上述问题，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收和 JS 脚本交替进行，直到标记阶段完成。这个算法称为"),s("code",[t._v("增量标记算法")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("p",[s("strong",[t._v("原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。")])]),t._v(" "),s("p",[t._v("对于垃圾回收机制，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。")])])}),[],!1,null,null,null);a.default=v.exports}}]);