(window.webpackJsonp=window.webpackJsonp||[]).push([[165],{524:function(t,v,_){"use strict";_.r(v);var s=_(41),r=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"微前端架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#微前端架构"}},[t._v("#")]),t._v(" 微前端架构")]),t._v(" "),_("p",[t._v("如何实现多个"),_("strong",[t._v("应用")]),t._v("之间的"),_("strong",[t._v("资源共享")]),t._v("？")]),t._v(" "),_("p",[t._v("之前比较多的处理方式是"),_("strong",[t._v("npm包形")]),t._v("式抽离和引用，比如多个应用项目之间，可能有某业务逻辑模块或者其他是可复用的，便抽离出来以npm包的形式进行管理和使用。但这样却带来了以下几个问题：")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("发布效率低下")]),t._v("。如果需要迭代npm包内的逻辑业务，需要先发布npm包之后，再每个使用了该npm包的应用都更新一次npm包版本，再各自构建发布一次，"),_("strong",[t._v("过程繁琐")]),t._v("。如果涉及到的应用更多的话，花费的人力和精力就更多了。")]),t._v(" "),_("li",[_("strong",[t._v("多团队协作容易不规范")]),t._v("。包含通用模块的npm包作为共享资产，“每个人”拥有它，但在实践中，这通常意味着没有人拥有它。它很快就会"),_("strong",[t._v("充满杂乱")]),t._v("的"),_("strong",[t._v("风格不一致")]),t._v("的代码，没有明确的约定或技术愿景。")])]),t._v(" "),_("p",[t._v("这些问题让我们意识到，扩展前端开发规模以便于"),_("strong",[t._v("多个团队")]),t._v("可以"),_("strong",[t._v("同时开发")]),t._v("一个大型且复杂的产品是一个重要但又棘手的难题。")]),t._v(" "),_("p",[t._v("因此，早在2016年，微前端概念诞生了。")]),t._v(" "),_("h2",{attrs:{id:"什么是微前端"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是微前端"}},[t._v("#")]),t._v(" 什么是微前端？")]),t._v(" "),_("p",[_("a",{attrs:{href:"https://micro-frontends.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Micro Frontends: https://micro-frontends.org/"),_("OutboundLink")],1),t._v("  官网定义了微前端概念：")]),t._v(" "),_("blockquote",[_("p",[t._v("Techniques, strategies and recipes for building a modern web app with multiple teams that can ship features independently.")]),t._v(" "),_("p",[t._v("建立一个"),_("strong",[t._v("现代网络应用程序")]),t._v("的技术，策略和食谱与"),_("strong",[t._v("多个团队")]),t._v("，可以"),_("strong",[t._v("独立运送功能")]),t._v("。")])]),t._v(" "),_("p",[t._v("从 Micro Frontends 官网可以了解到，微前端概念是从"),_("strong",[t._v("微服务")]),t._v("概念扩展而来的，摒弃大型单体方式，将前端整体分解为小而简单的块，这些块可以"),_("strong",[t._v("独立开发、测试和部署")]),t._v("，同时仍然"),_("strong",[t._v("聚合")]),t._v("为一个产品出现在客户面前。可以理解微前端是一种将多个"),_("strong",[t._v("可独立交付")]),t._v("的小型前端应用聚合为一个整体的架构风格。")]),t._v(" "),_("p",[t._v("值得留意的几个点：")]),t._v(" "),_("ul",[_("li",[t._v("微前端"),_("strong",[t._v("不是一门具体的技术")]),t._v("，而是整合了技术、策略和方法，可能会以脚手架、辅助插件和规范约束这种"),_("strong",[t._v("生态圈")]),t._v("形式展示出来，是一种宏观上的架构。这种"),_("strong",[t._v("架构")]),t._v("目前有"),_("strong",[t._v("多种方案")]),t._v("，都有利弊之处，但只要适用当前业务场景的就是好方案。")]),t._v(" "),_("li",[t._v("微前端并"),_("strong",[t._v("没有技术栈的约束")]),t._v("。每一套微前端方案的设计，都是基于实际需求出发。如果是多团队统一使用了react技术栈，可能对微前端方案的跨技术栈使用并没有要求；如果是多团队同时使用了react和vue技术栈，可能就对微前端的跨技术栈要求比较高。")])]),t._v(" "),_("h4",{attrs:{id:"微前端的使用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#微前端的使用场景"}},[t._v("#")]),t._v(" 微前端的使用场景")]),t._v(" "),_("ol",[_("li",[t._v("拆分巨型应用，使应用变得更加可维护")]),t._v(" "),_("li",[t._v("兼容历史应用，实现增量开发")])]),t._v(" "),_("h3",{attrs:{id:"微前端的优势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#微前端的优势"}},[t._v("#")]),t._v(" 微前端的优势")]),t._v(" "),_("h5",{attrs:{id:"同步更新"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#同步更新"}},[t._v("#")]),t._v(" 同步更新")]),t._v(" "),_("p",[t._v("对比了npm包方式抽离，让我们意识到"),_("strong",[t._v("更新流程和效率")]),t._v("的重要性。微前端由于是多个子应用的聚合，如果多个业务应用依赖同一个服务应用的功能模块，只需要更新服务应用，其他业务应用就可以立马更新，从而缩短了更新流程和节约了更新成本。")]),t._v(" "),_("h5",{attrs:{id:"增量升级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#增量升级"}},[t._v("#")]),t._v(" 增量升级")]),t._v(" "),_("p",[t._v("迁移是一项非常耗时且艰难的任务，比如有一个管理系统使用 AngularJS 开发维护已经有三年时间，但是随时间的推移和团队成员的变更，无论从开发成本还是用人需求上，AngularJS 已经不能满足要求，于是团队想要更新技术栈，想在其他框架中实现新的需求，但是现有项目怎么办？直接迁移是不可能的，在新的框架中完全重写也不太现实。")]),t._v(" "),_("p",[t._v("使用微前端架构就可以解决问题，在保留原有项目的同时，可以完全使用新的框架开发新的需求，然后再使用微前端架构将旧的项目和新的项目进行整合。这样既可以使产品得到更好的用户体验，也可以使团队成员在技术上得到进步，产品开发成本也降到的最低。")]),t._v(" "),_("h5",{attrs:{id:"独立部署与发布"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#独立部署与发布"}},[t._v("#")]),t._v(" 独立部署与发布")]),t._v(" "),_("p",[t._v("在目前的单页应用架构中，使用组件构建用户界面，应用中的每个组件或功能开发完成或者bug修复完成后，每次都需要对整个产品重新进行构建和发布，任务耗时操作上也比较繁琐。")]),t._v(" "),_("p",[t._v("在使用了微前端架构后，可以将不能的功能模块拆分成独立的应用，此时功能模块就可以单独构建单独发布了，构建时间也会变得非常快，应用发布后不需要更改其他内容应用就会自动更新，这意味着你可以进行频繁的构建发布操作了。")]),t._v(" "),_("h5",{attrs:{id:"独立团队决策"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#独立团队决策"}},[t._v("#")]),t._v(" 独立团队决策")]),t._v(" "),_("p",[t._v("因为微前端构架与框架无关，当一个应用由多个团队进行开发时，每个团队都可以使用自己擅长的技术栈进行开发，也就是它允许适当的让团队决策使用哪种技术，从而使团队协作变得不再僵硬。")]),t._v(" "),_("h3",{attrs:{id:"微前端落地方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#微前端落地方案"}},[t._v("#")]),t._v(" 微前端落地方案")]),t._v(" "),_("p",[_("strong",[t._v("自组织模式")]),t._v("：通过约定进行互调，但会遇到处理第三方依赖等问题。")]),t._v(" "),_("p",[_("strong",[t._v("基座模式")]),t._v("：通过搭建基座、配置中心来管理子应用。如基于SIngle Spa的偏通用的乾坤方案，也有基于本身团队业务量身定制的方案。")]),t._v(" "),_("p",[_("strong",[t._v("去中心模式")]),t._v("：脱离基座模式，每个应用之间都可以彼此分享资源。如基于Webpack 5 Module Federation实现的EMP微前端方案，可以实现多个应用彼此共享资源分享。")]),t._v(" "),_("p",[t._v("其中，目前值得关注是"),_("strong",[t._v("去中心模式")]),t._v("中的EMP微前端方案，既可以实现"),_("strong",[t._v("跨技术栈调用")]),t._v("，又可以在相同技术栈的应用间"),_("strong",[t._v("深度定制共享资源")]),t._v("。")]),t._v(" "),_("h2",{attrs:{id:"systemjs模块化解决方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#systemjs模块化解决方案"}},[t._v("#")]),t._v(" Systemjs模块化解决方案")]),t._v(" "),_("p",[t._v("在微前端架构中，微应用被打包为模块，但浏览器不支持模块化，需要使用 systemjs 实现浏览器中的模块化。")]),t._v(" "),_("p",[t._v("systemjs 是一个用于实现模块化的 JavaScript 库，有属于自己的模块化规范。")]),t._v(" "),_("p",[t._v("在开发阶段我们可以使用 ES 模块规范，然后使用 webpack 将其转换为 systemjs 支持的模块。")])])}),[],!1,null,null,null);v.default=r.exports}}]);