(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{404:function(v,_,e){"use strict";e.r(_);var o=e(41),s=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"promise-a-规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-a-规范"}},[v._v("#")]),v._v(" Promise A+ 规范")]),v._v(" "),e("p",[v._v("首先我们先介绍些名词")]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("解决（fulfill）")]),v._v("：指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 "),e("code",[v._v("fulfill")]),v._v(" 来表示解决，但在后世的 promise 实现多以 "),e("code",[v._v("resolve")]),v._v(" 来指代之。")]),v._v(" "),e("li",[e("strong",[v._v("拒绝（reject）")]),v._v("：指一个 promise 失败时进行的一系列操作。")]),v._v(" "),e("li",[e("strong",[v._v("终值（eventual value）")]),v._v("：所谓终值，指的是 promise 被"),e("strong",[v._v("解决")]),v._v("时传递给解决回调的值，由于 promise 有"),e("strong",[v._v("一次性")]),v._v("的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。")]),v._v(" "),e("li",[e("strong",[v._v("据因（reason）")]),v._v("：也就是拒绝原因，指在 promise 被"),e("strong",[v._v("拒绝")]),v._v("时传递给拒绝回调的值。")])]),v._v(" "),e("p",[v._v("Promise 表示一个异步操作的最终结果，与之进行交互的方式主要是 "),e("code",[v._v("then")]),v._v(" 方法，该方法注册了两个回调函数，用于接收 promise 的终值或本 promise 不能执行的原因。")]),v._v(" "),e("p",[v._v("一个 Promise 的当前状态必须为以下三种状态中的一种："),e("strong",[v._v("等待态（Pending）")]),v._v("、"),e("strong",[v._v("执行态（Fulfilled）"),e("strong",[v._v("和")]),v._v("拒绝态（Rejected）")]),v._v("。")]),v._v(" "),e("p",[e("strong",[v._v("等待态")]),v._v("（Pending）")]),v._v(" "),e("p",[v._v("处于等待态时，promise 需满足以下条件：")]),v._v(" "),e("ul",[e("li",[v._v("可以迁移至执行态或拒绝态")])]),v._v(" "),e("p",[e("strong",[v._v("执行态")]),v._v("（Fulfilled）")]),v._v(" "),e("p",[v._v("处于执行态时，promise 需满足以下条件：")]),v._v(" "),e("ul",[e("li",[v._v("不能迁移至其他任何状态")]),v._v(" "),e("li",[v._v("必须拥有一个"),e("strong",[v._v("不可变")]),v._v("的终值")])]),v._v(" "),e("p",[e("strong",[v._v("拒绝态")]),v._v("（Rejected）")]),v._v(" "),e("p",[v._v("处于拒绝态时，promise 需满足以下条件：")]),v._v(" "),e("ul",[e("li",[v._v("不能迁移至其他任何状态")]),v._v(" "),e("li",[v._v("必须拥有一个"),e("strong",[v._v("不可变")]),v._v("的据因")])]),v._v(" "),e("p",[v._v("这里的不可变指的是恒等（即可用 "),e("code",[v._v("===")]),v._v(" 判断相等），而不是意味着更深层次的不可变。")]),v._v(" "),e("p",[e("strong",[v._v("Then方法")])]),v._v(" "),e("p",[v._v("一个 promise 必须提供一个 "),e("code",[v._v("then")]),v._v(" 方法以访问其当前值、终值和据因。")]),v._v(" "),e("p",[v._v("promise 的 "),e("code",[v._v("then")]),v._v(" 方法接受两个参数：")]),v._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[v._v("promise"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("then")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("onFulfilled"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" onRejected"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n")])])]),e("p",[e("code",[v._v("onFulfilled")]),v._v(" 和 "),e("code",[v._v("onRejected")]),v._v(" 都是可选参数。")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("如果 "),e("code",[v._v("onFulfilled")]),v._v(" 不是函数，其必须被忽略")]),v._v(" "),e("p",[v._v("如果 "),e("code",[v._v("onFulfilled")]),v._v(" 是函数：")]),v._v(" "),e("ul",[e("li",[v._v("当 "),e("code",[v._v("promise")]),v._v(" 执行结束后其必须被调用，其第一个参数为 "),e("code",[v._v("promise")]),v._v(" 的终值")]),v._v(" "),e("li",[v._v("在 "),e("code",[v._v("promise")]),v._v(" 执行结束前其不可被调用")]),v._v(" "),e("li",[v._v("其调用次数不可超过一次")])])]),v._v(" "),e("li",[e("p",[v._v("如果 "),e("code",[v._v("onRejected")]),v._v(" 不是函数，其必须被忽略")]),v._v(" "),e("p",[v._v("如果 "),e("code",[v._v("onRejected")]),v._v(" 是函数：")]),v._v(" "),e("ul",[e("li",[v._v("当 "),e("code",[v._v("promise")]),v._v(" 被拒绝执行后其必须被调用，其第一个参数为 "),e("code",[v._v("promise")]),v._v(" 的据因")]),v._v(" "),e("li",[v._v("在 "),e("code",[v._v("promise")]),v._v(" 被拒绝执行前其不可被调用")]),v._v(" "),e("li",[v._v("其调用次数不可超过一次")])])])]),v._v(" "),e("p",[e("code",[v._v("then")]),v._v(" 方法必须返回一个 "),e("code",[v._v("promise")]),v._v(" 对象 注3")]),v._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[v._v("promise2 "),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" promise1"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("then")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("onFulfilled"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" onRejected"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("   \n")])])]),e("ul",[e("li",[v._v("如果 "),e("code",[v._v("onFulfilled")]),v._v(" 或者 "),e("code",[v._v("onRejected")]),v._v(" 返回一个值 "),e("code",[v._v("x")]),v._v(" ，则运行下面的 "),e("strong",[v._v("Promise 解决过程")]),v._v("："),e("code",[v._v("[[Resolve]](promise2, x)")])]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("onFulfilled")]),v._v(" 或者 "),e("code",[v._v("onRejected")]),v._v(" 抛出一个异常 "),e("code",[v._v("e")]),v._v(" ，则 "),e("code",[v._v("promise2")]),v._v(" 必须拒绝执行，并返回拒因 "),e("code",[v._v("e")])]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("onFulfilled")]),v._v(" 不是函数且 "),e("code",[v._v("promise1")]),v._v(" 成功执行， "),e("code",[v._v("promise2")]),v._v(" 必须成功执行并返回相同的值")]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("onRejected")]),v._v(" 不是函数且 "),e("code",[v._v("promise1")]),v._v(" 拒绝执行， "),e("code",[v._v("promise2")]),v._v(" 必须拒绝执行并返回相同的据因")])]),v._v(" "),e("h2",{attrs:{id:"promise-解决过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-解决过程"}},[v._v("#")]),v._v(" "),e("strong",[v._v("Promise 解决过程")])]),v._v(" "),e("p",[e("strong",[v._v("Promise 解决过程")]),v._v("是一个抽象的操作，其需输入一个 "),e("code",[v._v("promise")]),v._v(" 和一个值，我们表示为 "),e("code",[v._v("[[Resolve]](promise, x)")]),v._v("，如果 "),e("code",[v._v("x")]),v._v(" 有 "),e("code",[v._v("then")]),v._v(" 方法且看上去像一个 Promise ，解决程序即尝试使 "),e("code",[v._v("promise")]),v._v(" 接受 "),e("code",[v._v("x")]),v._v(" 的状态；否则其用 "),e("code",[v._v("x")]),v._v(" 的值来执行 "),e("code",[v._v("promise")]),v._v(" 。")]),v._v(" "),e("p",[v._v("运行 "),e("code",[v._v("[[Resolve]](promise, x)")]),v._v(" 需遵循以下步骤：")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("x")]),v._v(" 与 "),e("code",[v._v("promise")]),v._v(" 相等")])]),v._v(" "),e("p",[v._v("如果 "),e("code",[v._v("promise")]),v._v(" 和 "),e("code",[v._v("x")]),v._v(" 指向同一对象，以 "),e("code",[v._v("TypeError")]),v._v(" 为据因拒绝执行 "),e("code",[v._v("promise")])]),v._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[e("code",[v._v("x")]),v._v(" 为 Promise")])]),v._v(" "),e("p",[v._v("如果 "),e("code",[v._v("x")]),v._v(" 为 Promise ，则使 "),e("code",[v._v("promise")]),v._v(" 接受 "),e("code",[v._v("x")]),v._v(" 的状态 ：")]),v._v(" "),e("ul",[e("li",[v._v("如果 "),e("code",[v._v("x")]),v._v(" 处于等待态， "),e("code",[v._v("promise")]),v._v(" 需保持为等待态直至 "),e("code",[v._v("x")]),v._v(" 被执行或拒绝")]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("x")]),v._v(" 处于执行态，用相同的值执行 "),e("code",[v._v("promise")])]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("x")]),v._v(" 处于拒绝态，用相同的据因拒绝 "),e("code",[v._v("promise")])])]),v._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[e("code",[v._v("x")]),v._v(" 为对象或函数")])]),v._v(" "),e("p",[v._v("如果 "),e("code",[v._v("x")]),v._v(" 为对象或者函数：")]),v._v(" "),e("ul",[e("li",[v._v("把 "),e("code",[v._v("x.then")]),v._v(" 赋值给 "),e("code",[v._v("then")])]),v._v(" "),e("li",[v._v("如果取 "),e("code",[v._v("x.then")]),v._v(" 的值时抛出错误 "),e("code",[v._v("e")]),v._v(" ，则以 "),e("code",[v._v("e")]),v._v(" 为据因拒绝 "),e("code",[v._v("promise")])]),v._v(" "),e("li",[v._v("如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise，第二个参数叫做 rejectPromise:\n"),e("ul",[e("li",[v._v("如果 "),e("code",[v._v("resolvePromise")]),v._v(" 以值 "),e("code",[v._v("y")]),v._v(" 为参数被调用，则运行 "),e("code",[v._v("[[Resolve]](promise, y)")])]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("rejectPromise")]),v._v(" 以据因 "),e("code",[v._v("r")]),v._v(" 为参数被调用，则以据因 "),e("code",[v._v("r")]),v._v(" 拒绝 "),e("code",[v._v("promise")])]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("resolvePromise")]),v._v(" 和 "),e("code",[v._v("rejectPromise")]),v._v(" 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用")]),v._v(" "),e("li",[v._v("如果调用 then 方法抛出了异常 e：\n"),e("ul",[e("li",[v._v("如果 "),e("code",[v._v("resolvePromise")]),v._v(" 或 "),e("code",[v._v("rejectPromise")]),v._v(" 已经被调用，则忽略之")]),v._v(" "),e("li",[v._v("否则以 "),e("code",[v._v("e")]),v._v(" 为据因拒绝 "),e("code",[v._v("promise")])])])]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("then")]),v._v(" 不是函数，以 "),e("code",[v._v("x")]),v._v(" 为参数执行 "),e("code",[v._v("promise")])])])]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("x")]),v._v(" 不为对象或者函数，以 "),e("code",[v._v("x")]),v._v(" 为参数执行 "),e("code",[v._v("promise")])])])])}),[],!1,null,null,null);_.default=s.exports}}]);